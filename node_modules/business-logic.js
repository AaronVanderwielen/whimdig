var BusinessLogic = function (Mongo, Https, underscore, facebook) {
	var bl = this,
		db = Mongo.db,
		ObjectID = Mongo.objectID,
		https = Https,
		_ = underscore,
		FB = facebook,
		logJson = function (json) {
			console.log(JSON.stringify(json, null, 2));
		},
		chunkedCall = function (url, onEnd) {
			req = https.get(url, function (res) {
				var pageData = "";
				res.setEncoding('utf8');
				res.on('data', function (chunk) {
					pageData += chunk;
				});

				res.on('end', function () {
					var jsonObj = JSON.parse(pageData);
					onEnd(jsonObj);
				});
			}).on('error', function (e) {
				console.log("Got error: " + e.message);
				onEnd(false);
			});
		},
		jsonResponse = function (success, body, status) {
			return {
				success: success,
				body: body,
				statusCode: success ? 200 : status
			};
		},
		syncHandler = function (err, doc, callback, nullError) {
			if (!err) {
				if (nullError === true && doc === null) {
					console.log("ERR: Document not found");
					callback(new jsonResponse(false, "Document not found"));
				}
				else {
					callback(new jsonResponse(true, doc));
				}
			}
			else {
				console.log("ERR: " + err);
				callback(new jsonResponse(false, err));
			}
		};

	// event
	this.getEvent = function (fbId, eventId, callback) {
		var query = { _id: new ObjectID(eventId), users: fbId };

		db.collection('events').findOne(query, function (err, doc) {
			syncHandler(err, doc, callback, true);
		});
	};
	this.getAllEvents = function (fbId, callback) {
		var now = new Date(),
			maxHigh = new Date(now.getTime() + (3600000 * 48)),
			query = { start: { $lt: maxHigh }, end: { $gt: now }, $or: [{ privacy: 'public' }, { privacy: 'private', invited: fbId }] };

		db.collection('events').find(query).sort({ size: -1 }).toArray(function (err, doc) {
			syncHandler(err, doc, callback, true);
		});
	};
	this.getEventsForSpan = function (span, filters, bounds, fbId, callback) {
		if (!filters) { filters = ["nofilter"] };

		console.log("span: " + span);

		var now = new Date(),
			hours = span == 0 ? 12 : (span == 1 ? 24 : 48),
			high = new Date(now.getTime() + (3600000 * hours)),
			query = {
				$and: [
					{ start: { $lt: high } },
					{ end: { $gt: now } },
					{ 'tags.name': { $in: filters } },
					{ $or: [{ privacy: 'public' }, { privacy: 'private', invited: fbId }] },
					{
						loc: {
							$geoIntersects: {
								$geometry: {
									type: "Polygon",
									coordinates: [
										[
										[ parseFloat(bounds[0][0], 15), parseFloat(bounds[0][1], 15) ],
										[ parseFloat(bounds[1][0], 15), parseFloat(bounds[1][1], 15) ],
										[ parseFloat(bounds[2][0], 15), parseFloat(bounds[2][1], 15) ],
										[ parseFloat(bounds[3][0], 15), parseFloat(bounds[3][1], 15) ],
										[ parseFloat(bounds[4][0], 15), parseFloat(bounds[4][1], 15) ],
										]
									]
								}
							}
						}
					}
				]
			};
		console.log("hours: " + hours);
		console.log("high: " + high);

		db.collection('events').find(query).sort({ size: -1 }).toArray(function (err, doc) {
			syncHandler(err, doc, callback);
		});
	};
	this.getUserEvents = function (facebookId, callback) {
		var now = new Date(),
		tomorrow = new Date(now.getTime() + 86400000),
		query = { users: facebookId, end: { $gt: now } };

		db.collection('events').find(query).sort({ start: 1 }).toArray(function (err, doc) {
			syncHandler(err, doc, callback);
		});
	};
	this.getUserOwnedEvents = function (userId, callback) {
		var now = new Date(),
			query = { created_by: new ObjectID(userId), end: { $gt: now } };

		db.collection('events').find(query).sort({ start: 1 }).toArray(function (err, doc) {
			syncHandler(err, doc, callback);
		});
	};
	this.getUserPastEvents = function (facebookId, callback) {
		var now = new Date(),
			query = { users: facebookId, end: { $lt: now } };

		db.collection('events').find(query).sort({ start: -1 }).toArray(function (err, doc) {
			syncHandler(err, doc, callback);
		});
	};
	this.createEvent = function (eventData, user, callback) {
		var response = new jsonResponse(true, null);

		// get place
		db.collection('places').findOne({ _id: new ObjectID(eventData.place) }, function (err, doc) {
			syncHandler(err, doc, function (response) {
				if (response.success) {
					eventData.place = response.body;

					if (eventData.privacy === "private") {
						eventData.invited = _.map(user.friends, function (f) { return f.facebook_id; });
						eventData.invited.push(user.facebook_id);
					}

					// validate model
					eventData.created_by = new ObjectID(user._id);
					eventData.loc = eventData.place.loc;
					eventData.users = [];
					eventData.users.push(user.facebook_id);
					bl.validateEvent(eventData, function (response) {
						if (response.success) {
							db.collection('events').insert(eventData, function (err, doc) {
								syncHandler(err, doc, callback);
							});
						}
						else {
							callback(response);
						}
					});
				}
				else {
					callback(response);
				}
			}, true);
		});
	};
	this.updateEvent = function (eventData, user, callback) {
		var response = new jsonResponse(true, null),
			val;

		// get place
		db.collection('places').findOne({ _id: new ObjectID(eventData.place) }, function (err, doc) {
			syncHandler(err, doc, function (response) {
				if (response.success) {
					eventData.place = response.body;

					if (eventData.privacy === "private") {
						eventData.invited = _.map(user.friends, function (f) { return f.facebook_id; });
						eventData.invited.push(user.facebook_id);
					}

					// validate model
					bl.validateEvent(eventData, function (val) {
						if (val.success) {
							var id = eventData._id,
								query = { _id: new ObjectID(eventData._id), created_by: new ObjectID(user._id) };
							// remove _id before update so it doesn't try to set _id
							delete eventData._id;

							var update = { $set: eventData };

							db.collection('events').update(query, update, function (err, doc) {
								syncHandler(err, doc, function () {
									response.body = id;
									callback(response);
								});
							});
						}
						else {
							callback(val);
						}
					});
				}
				else {
					callback(response);
				}
			}, true);
		});
	};
	this.deleteEvent = function (eventId, userId, callback) {
		var query = { _id: new ObjectID(eventId), created_by: new ObjectID(userId) };
		db.collection('events').remove(query, function (err, doc) {
			syncHandler(err, doc, callback, true);
		});
	};
	this.validateEvent = function (event, callback) {
		var val = new jsonResponse(true, {});

		// TODO: check google place, set address, lat/lng, verify that current user can create this event
		// immediately or if it needs to get approved by another account

		event.start = new Date(event.start);
		event.end = new Date(event.end);
		event.tags = event.tags.split(',');

		if (event.start === "Invalid Date") {
			val.success = false;
			val.body.start = "Start datetime is invalid";
		}

		if (event.end === "Invalid Date") {
			val.success = false;
			val.body.end = "End datetime is invalid";
		}

		if (event.end <= event.start) {
			val.success = false;
			val.body.end = "This end date comes after the start date";
		}

		if (event.tags.length === 0) {
			val.success = false;
			val.body.end = "Please select at least one tag for your event";
		}

		if (event.tags.length > 3) {
			val.success = false;
			val.body.end = "You may only select up to 3 event tags";
		}
		if (val.success) {
			bl.getTagsByName(event.tags, function (response) {
				if (response.success) {
					event.tags = response.body;
				}
				else {
					val.success = false;
					val.body.end = "Invalid tags";
				}
				callback(new jsonResponse(val.success, val.body));
			});
		}
		else {
			callback(jsonResponse(val.success, val.body));
		}
	};
	this.addUserToEvent = function (userId, eventId, callback) {
		// TODO: check if event is public or shared w/user
		var query = { _id: new ObjectID(eventId), users: { $nin: [userId] } },
			update = { $inc: { size: 10 }, $addToSet: { users: userId } };

		db.collection('events').update(query, update, function (err, doc) {
			syncHandler(err, doc, callback);
		});
	};
	this.removeUserFromEvent = function (userId, eventId, callback) {
		var query = { _id: new ObjectID(eventId), users: userId },
		update = { $inc: { size: -10 }, $pull: { users: userId } };

		db.collection('events').update(query, update, function (err, doc) {
			syncHandler(err, doc, callback);
		});
	};
	this.getAllTags = function (callback) {
		db.collection('tags').find({}).toArray(function (err, doc) {
			syncHandler(err, doc, callback);
		});
	};
	this.getTagsByName = function (tagNames, callback) {
		var query = { name: { $in: tagNames } };

		db.collection('tags').find(query).toArray(function (err, doc) {
			syncHandler(err, doc, callback, true);
		});
	};
	this.createReview = function (user, eventId, rating, message, callback) {
		var now = new Date(),
			review = {
				user: {
					_id: new ObjectID(user._id),
					first_name: user.first_name
				},
				rating: rating,
				message: message,
				date_created: now
			},
			query = {
				_id: ObjectID(eventId),
				users: user.facebook_id,
				end: { $lt: now },
				reviews: { $ne: { user: user } }
			},
			update = { $addToSet: { reviews: review } };

		db.collection('events').update(query, update, function (err, doc) {
			syncHandler(err, doc, callback);
		});
	};
	// user
	this.getUser = function (userId, callback) {
		var query = { _id: new ObjectID(userId) };

		db.collection('users').findOne(query, function (err, doc) {
			syncHandler(err, doc, callback);
		});
	};
	this.getFacebookFriends = function (token, callback) {
		var options = {
			fields: "id,name,picture"
		};

		FB.getFbData(token, '/me/friends', options, function (fbResponse) {
			fbResponse = JSON.parse(fbResponse);
			var friendData = _.map(fbResponse.data, function (f) {
				return {
					facebook_id: f.id,
					name: f.name,
					picture_url: f.picture.data.url
				};
			});
			callback(friendData);
		});
	};
	this.getUserPlaces = function (userId, callback) {
		var query = { _id: new ObjectID(userId) },
			projection = { places: 1, _id: 0 };

		db.collection('users').findOne(query, projection, function (err, doc) {
			syncHandler(err, doc, callback);
		});
	};
	this.addPlaceToUser = function (userId, placeId, callback) {
		db.collection('places').findOne({ _id: new ObjectID(placeId) }, function (err, place) {
			if (!err) {
				if (place !== null) {
					// add place to user
					var query = { _id: new ObjectID(userId) },
						update = { $addToSet: { places: place } };

					db.collection('users').update(query, update, function (err, doc) {
						syncHandler(err, doc, callback, true);
					});
				}
				else {
					callback(new jsonResponse(false, "Place does not exist"));
				}
			}
			else {
				callback(new jsonResponse(false, err));
			}
		});
	};
	this.getUserIds = function () {
		var contacts = getUserContacts();
		// now look in mongo database for that user
	};
	this.checkFacebookToken = function (token, fbUserID, callback) {
		var fbAuthUrl = "https://graph.facebook.com/me?access_token=" + token;
		chunkedCall(fbAuthUrl, function (response) {
			//	"id": "",
			//	"email": "",
			//	"first_name": "",
			//	"gender": "",
			//	"last_name": "",
			//	"link": "",
			//	"locale": "en_US",
			//	"name": "Aaron ",
			//	"timezone": -7,
			//	"updated_time": "2014-06-11T02:32:33+0000",
			//	"verified": true
			if (response.id === fbUserID) {
				var user = {
					facebook_id: response.id,
					first_name: response.first_name,
					last_name: response.last_name
				};
				callback(user);
			}
			else {
				callback(false);
			}
		});
	};
	this.authenticate = function (token, fbUserID, callback) {
		// verify client's sent id with facebook session
		bl.checkFacebookToken(token, fbUserID, function (fbUser) {
			if (fbUser.facebook_id) {
				// query database for user
				var query = { facebook_id: fbUser.facebook_id };
				db.collection('users').findOne(query, function (err, dbUser) {
					if (!err) {
						bl.getFacebookFriends(token, function (friends) {
							fbUser.friends = friends;

							if (dbUser === null) {
								// create user in our db
								console.log("create user in our db");
								db.collection('users').insert(fbUser, function (err, doc) {
									if (!err) {
										// now return inserted dbUser
										db.collection('users').findOne({ facebook_id: fbUser.facebook_id }, function (err, doc) {
											syncHandler(err, doc, callback, true);
										});
									}
									else {
										callback(new jsonResponse(false, err));
									}
								});
							}
							else {
								if (dbUser.friends !== fbUser.friends) {
									// update db user with fbUser
									db.collection('users').update({ _id: dbUser._id }, { $set: fbUser }, function (err, doc) {
										if (!err) {
											// update user's current private event authorized list
											var query = { created_by: dbUser._id, privacy: "private" },
												inviteIds = _.map(dbUser.friends, function (f) { return f.facebook_id; });

											db.collection('users').update(query, { $set: { invited: inviteIds } }, function (err, doc) {
												syncHandler(err, doc, function (response) {
													// now return updated dbUser
													db.collection('users').findOne({ facebook_id: fbUser.facebook_id }, function (err, doc) {
														syncHandler(err, doc, callback, true);
													});
												});
											});
										}
										else {
											callback(new jsonResponse(false, err));
										}
									});
								}
							}
						});
					}
					else {
						callback(new jsonResponse(false, err));
					}
				});
			}
			else {
				console.log("Facebook token authentication failed");
				callback();
			}
		});
	};
	// places
	this.placesSearchAll = function (key, lat, lng, name, callback) {
		var placesArray = [],
			query = { name: { $regex: name, $options: 'i' } };

		if (name === null || name === undefined) {
			callback(new jsonResponse(false, "Name is null"));
		}

		db.collection('places').find(query).toArray(function (err, doc) {
			if (!err) {
				for (var d in doc) {
					placesArray.push(doc[d]);
				}
				// query google to see if we're missing results
				bl.placesApiSearchByName(key, lat, lng, name, function (apiResponse) {
					if (apiResponse.success) {
						var apiPlaceIds = _.filter(apiResponse.body, function (p) { return p.place_id; });

						// query the returned places against our db to see avoid adding duplicates
						bl.getPlacesByPlaceId(apiPlaceIds, function (dbResponse) {
							if (dbResponse.success) {
								// filter out apiPlaces that are already in db
								var placesToAdd = _.filter(apiResponse.body, function (apiP) {
									return !_.some(dbResponse.body, function (dbP) {
										return dbP.place_id === apiP.place_id;
									});
								});
								for (var p in placesToAdd) {
									placesArray.push(placesToAdd[p]);
								}
								// add any non-local places to db
								if (placesToAdd.length > 0) {
									db.collection('places').insert(placesToAdd, function (err, doc) {
										if (err) {
											console.log(err);
										}
										callback(new jsonResponse(true, placesArray));
									});
								}
								else {
									callback(new jsonResponse(true, placesArray));
								}
							}
						});
					}
				});
			}
			else {
				console.log("ERR: " + err);
				callback(new jsonResponse(false, err));
			}
		});
	};
	this.placesApiTestSearch = function (key, lat, lng, radius, callback) {
		var types = 'night_club',//'food|bakery|bar|book_store|bowling_alley|cafe|casino|movie_theater|night_club|park|restaurant|university',
			url = "https://maps.googleapis.com/maps/api/place/search/json?key=" + key + "&location=" + lat + "," + lng + "&radius=5000" + "&types=" + types; //"&radius=" + radius;

		chunkedCall(url, function (response) {
			if (response) {
				var results = response.results,
					formatted = [];
				console.log(JSON.stringify(results));
				for (var r in results) {
					//geometry: Object
					////location: Object
					//////lat: 47.7312073
					//////lng: -122.552361
					////viewport: Object
					//////northeast: Object
					////////lat: 47.7443259
					////////lng: -122.5491167
					//////southwest: Object
					//icon: "http://maps.gstatic.com/mapfiles/place_api/icons/geocode-71.png"
					//id: "3d1c3b332fb6c44dd0b007211bf3d4b303f28ed4"
					//name: "Suquamish"
					//place_id: "ChIJwS8NQdQikFQRwGmYU_FJJAc"
					//reference: "CoQBfQAAAETU4auAS-vVd9DgxW_bjqJNAt1f509tvBn87VnVj-WNInfzEcPuJw7yffyEkz-9KVMdolVLjlzjIKx0GRKoM2kp3oLR85U5jNozniNqqYKr_iv3b4vLfZRqVvOJOdCOz54WKceINAnMJ7NSiX3xAllg7Aaomzv57w2OKAnkS8-_EhAxemVLQ3LVqBVgfICzNAm9GhSJaBsLTDyRm6eyOhe_eZc3HnIMHg"
					//scope: "GOOGLE"
					//types: Array[2]
					////0: "locality"
					////1: "political"
					//length: 2
					//__proto__: Array[0]
					//vicinity: "Suquamish"
					formatted.push({
						place_id: results[r].place_id,
						name: results[r].name,
						loc: { type: "Point", coordinates: [parseFloat(results[r].geometry.location.lng, 15), parseFloat(results[r].geometry.location.lat, 15)] },
						vicinity: results[r].vicinity
					});
				}
				db.collection('places').insert(formatted, function (err, doc) {
					if (!err) {
						callback(new jsonResponse(true, doc));
					}
					else {
						console.log("ERR: " + err);
						callback(new jsonResponse(false, err));
					}
				});
			}
			else {
				callback(new jsonResponse(false, response));
			}
		});
	};
	this.placesApiSearchByName = function (key, lat, lng, name, callback) {
		var url = "https://maps.googleapis.com/maps/api/place/search/json?key=" + key + "&location=" + lat + "," + lng + "&rankby=distance" + "&name=" + name;
		chunkedCall(url, function (response) {
			if (response) {
				var results = response.results,
					formatted = [];

				for (var r in results) {
					formatted.push({
						place_id: results[r].place_id,
						name: results[r].name,
						loc: { type: "Point", coordinates: [results[r].geometry.location.lng, results[r].geometry.location.lat] },
						vicinity: results[r].vicinity
					});
				}
				callback(new jsonResponse(true, formatted));
			}
			else {
				callback(new jsonResponse(false, response));
			}
		});
	};
	this.placesSearchName = function (name, callback) {
		var query = {},
			projection = { name: 1, _id: 0 };

		db.collection('places').find(query, projection).toArray(function (err, doc) {
			if (!err) {
				var names = [];
				for (var d in doc) {
					names.push(doc[d].name);
				}
				callback(new jsonResponse(true, names));
			}
			else {
				console.log("ERR: " + err);
				callback(new jsonResponse(false, err));
			}
		});
	};
	this.getPlacesByPlaceId = function (placeIds, callback) {
		var query = { place_id: { $in: placeIds } };

		db.collection('places').find(query).toArray(function (err, doc) {
			syncHandler(err, doc, callback);
		});
	};

	// TEST METHODS
	this.insertFilters = function (callback) {
		var filters = [
			{
				name: "music",
				glyph: "music",
				label: "Music"
			},
			{
				name: "alcohol",
				glyph: "beer",
				label: "Alcohol"
			},
			{
				name: "food",
				glyph: "cutlery",
				label: "Food"
			},
			{
				name: "pets",
				glyph: "dog",
				label: "Pets"
			},
			{
				name: "games",
				glyph: "playing_dices",
				label: "Games"
			},
			{
				name: "books",
				glyph: "book",
				label: "Books"
			},
			{
				name: "video_games",
				glyph: "gamepad",
				label: "Video Games"
			},
			{
				name: "sports",
				glyph: "soccer_ball",
				label: "Sports"
			},
			{
				name: "birthday",
				glyph: "birthday_cake",
				label: "Birthday"
			},
			{
				name: "movie",
				glyph: "film",
				label: "Movie/TV"
			}
		]
		db.collection('tags').insert(filters, function (err, doc) {
			return callback(doc);
		});
	}
};

module.exports = BusinessLogic;