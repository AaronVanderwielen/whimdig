var BusinessLogic = function (opts) {
	var bl = this,
        // PROD : AIzaSyDEQiAImA3u9GB8EiF0NFMZH9Wy10AVTWg
        // TEST : AIzaSyB9EARriTjyHo7LupKAHvazcG245a04c54
        googleBrowserApiKey = 'AIzaSyDEQiAImA3u9GB8EiF0NFMZH9Wy10AVTWg',
        // PROD : AIzaSyDBVBsIxFaRG2mIdQF7uZQ7I4ca_jAJ8mQ
        // TEST : AIzaSyB9EARriTjyHo7LupKAHvazcG245a04c54
        googleServerApiKey = 'AIzaSyDBVBsIxFaRG2mIdQF7uZQ7I4ca_jAJ8mQ',
		db = opts.database,
		ObjectID = opts.objectID,
		https = opts.https,
		_ = opts.underscore,
		FB = opts.facebook,
		s = opts.schema,
		logJson = function (json) {
			console.log(JSON.stringify(json, null, 2));
		},
		chunkedCall = function (url, onEnd) {
			req = https.get(url, function (res) {
				var pageData = "";
				res.setEncoding('utf8');
				res.on('data', function (chunk) {
					pageData += chunk;
				});

				res.on('end', function () {
					var jsonObj = JSON.parse(pageData);
					onEnd(jsonObj);
				});
			}).on('error', function (e) {
				console.log("Got error: " + e.message);
				onEnd(false);
			});
		},
		jsonResponse = function (success, body, status) {
			return {
				success: success,
				body: body,
				statusCode: success ? 200 : status
			};
		},
		syncHandler = function (err, doc, callback, nullError) {
			if (!err) {
				if (nullError === true && (doc === null || doc === 0)) {
					callback(new jsonResponse(false, "Document not found"));
				}
				else {
					callback(new jsonResponse(true, doc));
				}
			}
			else {
				console.log("ERR: " + err);
				callback(new jsonResponse(false, err));
			}
		};

	// event
	this.getUpcomingEvents = function (tags, span, radius, loc, userId, callback) {
		if (tags) {
			for (var f in tags) {
				tags[f] = new ObjectID(tags[f]);
			}
		}
		else {
			tags = [];
		}

		// limit filters
		radius = radius > 100 ? 100 : radius;
		span = span > 48 ? 48 : span;

		var now = new Date(),
			high = new Date(now.getTime() + (3600000 * span)),
			meters = radius * 1609.344, // convert mile to meters
			projection = null,
			query = {
				$and: [
					{ start: { $lt: high } },
					{ end: { $gt: now } },
					{ _tags: { $in: tags } },
					{ $or: [{ privacy: 'public' }, { privacy: 'private', _invited: userId }] },
					{
						loc: {
							$near: {
								$geometry: { type: "Point", coordinates: [parseFloat(loc.lng, 15), parseFloat(loc.lat, 15)] },
								$maxDistance: parseFloat(meters, 2)
							}
						}
					}
				]
			},
			opts = {
				sort: { start: 1 }
			};

		s.event.find(query, projection, opts)
			//.skip(page * resultsPerPage)
			//.limit(resultsPerPage)
			.populate('_place')
			.populate('_tags')
			.exec(function (err, doc) {
				syncHandler(err, doc, callback);
			});
	};
	this.getEventsForBounds = function (span, filters, bounds, userId, callback) {
		var now = new Date(),
			hours = 12,
			high = new Date(now.getTime() + (3600000 * hours)),
			query = {
				$and: [
					{ start: { $lt: high } },
					{ end: { $gt: now } },
					{ $or: [{ privacy: 'public' }, { privacy: 'private', _invited: userId }] },
					{
						loc: {
							$geoIntersects: {
								$geometry: {
									type: "Polygon",
									coordinates: [
										[
										[parseFloat(bounds[0][0], 15), parseFloat(bounds[0][1], 15)],
										[parseFloat(bounds[1][0], 15), parseFloat(bounds[1][1], 15)],
										[parseFloat(bounds[2][0], 15), parseFloat(bounds[2][1], 15)],
										[parseFloat(bounds[3][0], 15), parseFloat(bounds[3][1], 15)],
										[parseFloat(bounds[4][0], 15), parseFloat(bounds[4][1], 15)],
										]
									]
								}
							}
						}
					}
				]
			},
			projection = '_id start end intensity_variable loc _users',
			opts = null;

		s.event.find(query, projection, opts, function (err, doc) {
			syncHandler(err, doc, callback);
		});
	};
	this.getUserEvent = function (userId, eventId, callback) {
		var query = { _id: new ObjectID(eventId), _users: userId };

		s.event.findOne(query)
			.populate('_place')
			.populate('_tags')
			.exec(function (err, doc) {
				syncHandler(err, doc, callback, true);
			});
	};
	this.getEvents = function (ids, callback) {
		var now = new Date(),
		projection = null,
		query = { _id: { $in: ids } },
		opts = {
			sort: { start: 1 }
		};

		s.event.find(query, projection, opts)
			.populate('_place')
			.populate('_tags')
			.exec(function (err, doc) {
				syncHandler(err, doc, callback);
			});
	};
	this.getUserEvents = function (userId, callback) {
		var now = new Date(),
		tomorrow = new Date(now.getTime() + 86400000),
		query = { _users: userId, end: { $gt: now } },
		projection = null,
		opts = {
			sort: { start: 1 }
		};

		s.event.find(query, projection, opts)
			.populate('_place')
			.populate('_tags')
			.exec(function (err, doc) {
				syncHandler(err, doc, callback);
			});
	};
	this.getUserOwnedEvents = function (userId, callback) {
		var now = new Date(),
			query = { _created_by: new ObjectID(userId), end: { $gt: now } },
			projection = null,
			opts = {
				sort: { start: 1 }
			};

		s.event.find(query, projection, opts)
			.populate('place')
			.exec(function (err, doc) {
				syncHandler(err, doc, callback);
			});
	};
	this.getUserPastEvents = function (userId, callback) {
		var now = new Date(),
			query = { _users: userId, end: { $lt: now } },
			projection = null,
			opts = {
				sort: { start: -1 }
			};

		s.event.find(query, projection, opts)
			.populate('_place')
			.exec(function (err, doc) {
				syncHandler(err, doc, callback);
			});
	};
	//// event CRUD
	this.getEvent = function (eventId, callback) {
		var query = { _id: new ObjectID(eventId) };

		s.event.findOne(query)
			.populate('_place')
			.populate('_tags')
			.populate('_created_by')
			.exec(function (err, doc) {
				syncHandler(err, doc, callback, true);
			});
	};
	this.createEvent = function (eventData, user, callback) {
		var response = new jsonResponse(true, null),
			query = { _id: new ObjectID(eventData._place) };

		// get place
		s.place.findOne(query, function (err, doc) {
			syncHandler(err, doc, function (response) {
				if (response.body) {
					eventData._place = response.body;
					// set the event's location using the place's
					eventData.loc = eventData._place.loc;
				}

				if (eventData.privacy === "private") {
					eventData._invited = user._friends;
					eventData._invited.push(user._id);
				}

				if (user) {
					// set current user to creator
					eventData._created_by = new ObjectID(user._id);

					// add current user to the event
					eventData._users = [];
					eventData._users.push(user._id);
				}

				// convert string Ids to ObjectIDs
				eventData._tags = eventData._tags.split(",").filter(function (e) { return e });
				for (var t in eventData._tags) {
					eventData._tags[t] = new ObjectID(eventData._tags[t]);
				}

				//bl.validateEvent(eventData, function (response) {
				var eventModel = new s.event(eventData);
				eventModel.save(function (err, doc) {
					syncHandler(err, doc, callback);
				});
			});
		});
	};
	this.updateEvent = function (eventData, user, callback) {
		var response = new jsonResponse(true, null),
            eventQuery = { _id: new ObjectID(eventData._id), _created_by: new ObjectID(user._id) },
			placeQuery = { _id: new ObjectID(eventData._place) };

		s.event.findOne(eventQuery, function (err, doc) {
			syncHandler(err, doc, function (response) {
				var dbEvent = response.body;

				// set the easy ones
				dbEvent.name = eventData.name;
				dbEvent.desc = eventData.desc;
				dbEvent.start = eventData.start;
				dbEvent.end = eventData.end;
				dbEvent.privacy = eventData.privacy;
				dbEvent.intensity_variable = eventData.intensity_variable;

				// set ._tags
				eventData._tags = eventData._tags.split(",").filter(function (e) { return e });
				for (var t in eventData._tags) {
					eventData._tags[t] = new ObjectID(eventData._tags[t]);
				}
				dbEvent._tags = eventData._tags;

				// set privacy
				dbEvent.privacy = eventData.privacy;
				if (dbEvent.privacy === "private") {
					dbEvent._invited = user._friends;
					dbEvent._invited.push(user._id);
				}

				// set place
				dbEvent._place = new ObjectID(eventData._place);

				// update event in db
				dbEvent.save(function (err, doc) {
					syncHandler(err, doc, callback);
				});

			}, true);
		});
	};
	this.deleteEvent = function (eventId, userId, callback) {
		var query = { _id: new ObjectID(eventId), _created_by: new ObjectID(userId) };
		db.collection('events').remove(query, function (err, doc) {
			syncHandler(err, doc, callback, true);
		});
	};
	//// event - user relation
	this.addUserToEvent = function (userId, eventId, callback) {
		// TODO: check if event is public or shared w/user
		var query = { _id: new ObjectID(eventId), _users: { $nin: [userId] } },
			update = { $addToSet: { _users: userId } };

		s.event.findOneAndUpdate(query, update, function (err, doc) {
			syncHandler(err, doc, callback, true);
		});
	};
	this.removeUserFromEvent = function (userId, eventId, callback) {
		var query = {
			_id: new ObjectID(eventId),
			_users: userId,
			_created_by: { $ne: new ObjectID(userId) }
		},
		update = {
			$pull: { _users: userId }
		};

		s.event.findOneAndUpdate(query, update, function (err, doc) {
			syncHandler(err, doc, callback, true);
		});
	};
	//// event tags
	this.getAllTags = function (callback) {
		s.tag.find({}, function (err, doc) {
			syncHandler(err, doc, callback);
		});
	};
	this.getTagsByName = function (tagNames, callback) {
		var query = { name: { $in: tagNames } };

		s.tag.find(query, function (err, doc) {
			syncHandler(err, doc, callback, true);
		});
	};
	//// event messaging
	this.addMsgToEvent = function (msg, eventId, user, callback) {
		var message = {
			text: msg,
			date: new Date(),
			facebook_id: user.facebook_id,
			_created_by: user._id
		},
			query = { _id: new ObjectID(eventId), _users: new ObjectID(user._id) },
			update = { $push: { messages: message } };

		s.event.findOneAndUpdate(query, update, function (err, doc) {
			if (!err) {
				callback(message);
			}
		});
	};
	// user
	this.getUser = function (userId, callback) {
		var query = { _id: new ObjectID(userId) };

		s.user.findOne(query, function (err, user) {
			syncHandler(err, user, callback);
		});
	};
	this.getUserIdsByFbIds = function (facebookIds, callback) {
		var query = { facebook_id: { $in: facebookIds } },
			projection = { _id: 1 };

		s.user.find(query, projection, function (err, doc) {
			if (!err) {
				var ids = _.map(doc, function (d) { return d._id; });
				callback(ids);
			}
		});
	},
	this.getUserPlaces = function (userId, callback) {
		var query = { _id: new ObjectID(userId) },
			projection = { _places: 1, _id: 0 };

		s.user.findOne(query, projection)
			.populate('_places')
			.exec(function (err, doc) {
				syncHandler(err, doc, callback);
			});
	};
	this.addPlaceToUser = function (userId, placeId, callback) {
		console.log(userId);
		console.log(placeId);
		var placeQuery = { _id: placeId };

		s.place.findOne(placeQuery, function (err, place) {
			syncHandler(err, place, function (response) {
				if (response.success) {
					// add place to user
					var query = { _id: new ObjectID(userId) },
						update = { $addToSet: { _places: place } };

					s.user.findOneAndUpdate(query, update, function (err, user) {
						syncHandler(err, place, callback, true);
					});
				}
				else {
					callback(response);
				}
			}, true);
		});
	};
	this.authenticate = function (token, fbUserID, callback) {
		// verify client's sent id with facebook session
		bl.checkFacebookToken(token, fbUserID, function (fbUser) {
			if (fbUser.facebook_id) {
				// query database for user
				var userQuery = { facebook_id: fbUser.facebook_id };
				s.user.findOne(userQuery, function (err, dbUser) {
					if (!err) {
						bl.getFacebookFriends(token, function (friends) {
							var fbFriendIds = _.map(friends, function (f) { return f.facebook_id; });

							bl.getUserIdsByFbIds(fbFriendIds, function (userIds) {
								if (dbUser === null) {
									// create user in our db
									fbUser["last_login"] = new Date();
									var newUser = new s.user(fbUser);
									newUser.save(function (err, doc) {
										syncHandler(err, doc, callback, true);
									});
								}
								else {
									dbUser["last_login"] = new Date();
									// check if friends list is different since last login
									var diff = _.difference(userIds, dbUser._friends).length !== 0;
									if (diff) {
										// update user's friends list
										dbUser._friends = userIds;
										dbUser.save(function (err, dbUser) {
											// update user's private events' authorized list
											var query = { _created_by: dbUser._id, privacy: "private" },
												eventUpdate = { $set: { _invited: dbUser._friends } };

											s.event.update(query, eventUpdate, function (err, doc) {
												// now return updated dbUser
												if (!err) {
													callback(new jsonResponse(true, dbUser));
												}
												else {
													callback(new jsonResponse(false, err));
												}
											});
										});
									}
									else {
										dbUser.save(function (err, dbUser) {
											callback(new jsonResponse(true, dbUser));
										});
									}
								}
							});
						});
					}
					else {
						callback(new jsonResponse(false, err));
					}
				});
			}
			else {
				console.log("Facebook token authentication failed");
				callback();
			}
		});
	};
	//// mail
	this.getUserMail = function (userId, callback) {
		var query = { _users: new ObjectID(userId) },
			projection = {
				_id: 1, subject: 1, read_log: 1, messages: -1, _users: 1
			},
			opts = {
				sort: { last_modified: -1 }
			};

		s.mail.find(query, projection, opts)
			.populate('_users')
			.exec(function (err, doc) {
				syncHandler(err, doc, callback);
			});
	};
	this.getMailMessages = function (mailId, userId, callback) {
		var query = { _id: new ObjectID(mailId), _users: new ObjectID(userId) };
		//projection = { _id: -1, _messages: 1 };

		s.mail.findOne(query)
			//.populate('_messages')
			.exec(function (err, doc) {
				if (!err && doc) {
					if (doc.read_log.indexOf(userId) > -1) {
						syncHandler(err, doc, callback);
					}
					else {
						doc.read_log.push(userId);
						doc.save(function (err, doc) {
							syncHandler(err, doc, callback);
						});
					}
				}
				else {
					callback(new jsonResponse(false, ''));
				}
			});
	};
	this.createMail = function (toFacebookIds, msg, user, callback) {
		// TODO: check if toIds are friends
		if (toFacebookIds.length > 0) {
			toFacebookIds = toFacebookIds.split(",");
			bl.getUserIdsByFbIds(toFacebookIds, function (userIds) {
				if (userIds.length > 0) {
					userIds.push(new ObjectID(user._id));

					var now = new Date(),
						subject = msg.length > 50 ? msg.substring(0, 50) : msg,
						mail = new s.mail({
							subject: subject,
							messages: [],
							read_log: [user._id],
							last_modified: new Date(),
							_users: userIds
						}),
						message = {
							date: now,
							text: msg,
							facebook_id: user.facebook_id,
							_created_by: user._id
						};

					mail.messages.push(message);
					mail.save(function (err, mail) {
						if (!err) {
							var query = { _id: { $in: userIds } },
								update = { $push: { _mail: mail._id } };

							db.collection('users').update(query, update, function (err, doc) {
								syncHandler(err, doc, callback);
							});
						}
						else {
							callback(new jsonResponse(false, err));
						}
					});
				}
				else {
					callback(new jsonResponse(false, "Couldn't find user"));
				}
			});
		}
		else {
			callback(new jsonResponse(false, "Couldn't find user"));
		}
	};
	this.addMsgToMail = function (mailId, text, user, callback) {
		var query = { _id: mailId, _users: user._id };

		s.mail.findOne(query, function (err, mail) {
			if (!err && mail) {
				mail.messages.push({
					date: new Date(),
					text: text,
					facebook_id: user.facebook_id,
					_created_by: user._id
				});
				mail.read_log = [user._id];
				mail.last_modified = new Date();
				mail.subject = text.length > 50 ? text.substring(0, 50) : text;

				mail.save(function (err, mail) {
					syncHandler(err, mail, callback);
				});
			}
		});
	};
	//// facebook
	this.checkFacebookToken = function (token, fbUserID, callback) {
		var fbAuthUrl = "https://graph.facebook.com/me?access_token=" + token;
		chunkedCall(fbAuthUrl, function (response) {
			//	"id": "",
			//	"email": "",
			//	"first_name": "",
			//	"gender": "",
			//	"last_name": "",
			//	"link": "",
			//	"locale": "en_US",
			//	"name": "Aaron ",
			//	"timezone": -7,
			//	"updated_time": "2014-06-11T02:32:33+0000",
			//	"verified": true
			if (response.id === fbUserID) {
				var user = {
					facebook_id: response.id,
					first_name: response.first_name,
					last_name: response.last_name
				};
				callback(user);
			}
			else {
				callback(false);
			}
		});
	};
	this.getFacebookFriends = function (token, callback) {
		var options = {
			fields: "id,name,picture"
		};

		FB.getFbData(token, '/me/friends', options, function (fbResponse) {
			fbResponse = JSON.parse(fbResponse);
			var friendData = _.map(fbResponse.data, function (f) {
				return {
					facebook_id: f.id,
					name: f.name,
					picture_url: f.picture.data.url
				};
			});
			callback(friendData);
		});
	};
	// places
	this.getPlaceById = function (id, callback) {
		var query = { _id: new ObjectID(id) };

		s.place.findOne(query, function (err, doc) {
			syncHandler(err, doc, callback, true);
		});
	};
	this.getPlaceUpcomingEvents = function (placeId, userId, callback) {
		var now = new Date(),
			query = {
				end: { $gt: now },
				$or: [{ privacy: 'public' }, { privacy: 'private', _invited: userId }],
				_place: new ObjectID(placeId)
			},
			projection = null,
			options = {
				limit: 15,
				sort: { start: 1 }
			};

		s.event.find(query, projection, options)
			.populate('_place', 'name')
			.exec(function (err, doc) {
				syncHandler(err, doc, callback);
			});
	};
	this.getPlacePastEvents = function (placeId, userId, callback) {
		var now = new Date(),
			query = {
				end: { $lt: now },
				$or: [{ privacy: 'public' }, { privacy: 'private', _invited: userId }],
				_place: new ObjectID(placeId)
			},
			projection = null,
			options = {
				limit: 15,
				sort: { end: -1 }
			};

		s.event.find(query, projection, options)
			.populate('_place', 'name')
			.exec(function (err, doc) {
				syncHandler(err, doc, callback);
			});
	};
	this.placesSearchAll = function (lat, lng, name, callback) {
		var placesQueryResponse = [],
			query = { name: { $regex: name, $options: 'i' } };

		if (name === null || name === undefined) {
			callback(new jsonResponse(false, "Name is null"));
		}

		s.place.find(query, function (err, doc) {
			if (!err) {
				for (var d in doc) {
					placesQueryResponse.push(doc[d]);
				}
				// query google to see if we're missing results
				bl.placesApiSearchByName(lat, lng, name, function (apiResponse) {
					if (apiResponse.success) {
						bl.createPlacesFromAPI(apiResponse.body, function (newPlacesResponse) {
							if (newPlacesResponse.success) {
								for (var p in newPlacesResponse.body) {
									placesQueryResponse.push(newPlacesResponse.body[p]);
								}
							}
							callback(new jsonResponse(true, placesQueryResponse));
						});
					}
					else {
						callback(new jsonResponse(true, placesQueryResponse));
					}
				});
			}
			else {
				console.log("ERR: " + err);
				callback(new jsonResponse(false, err));
			}
		});
	};
	this.importGooglePlace = function (place, callback) {
		bl.getPlacesByPlaceId([ place.place_id ], function (response) {
			if (response.success && response.body.length === 0) {
				place.loc[0] = parseFloat(place.loc[0], 15);
				place.loc[1] = parseFloat(place.loc[1], 15);
				var newPlace = new s.place(place);
				newPlace.save(function (err, doc) {
					syncHandler(err, doc, callback);
				});
			}
			else {
				callback(new jsonResponse(true, response.body[0]));
			}
		});
	};
	this.createPlacesFromAPI = function (apiResponse, callback) {
		var apiPlaceIds = _.map(apiResponse, function (p) { return p.place_id; });

		// query the returned places against our db to see avoid adding duplicates
		bl.getPlacesByPlaceId(apiPlaceIds, function (dbResponse) {
			if (dbResponse.success) {
				// filter out apiPlaces that are already in db
				var placesToAdd = _.filter(apiResponse, function (apiP) {
					return !_.some(dbResponse.body, function (dbP) {
						return dbP.place_id === apiP.place_id;
					});
				});
				// add any non-local places to db
				if (placesToAdd.length > 0) {
					db.collection('places').insert(placesToAdd, function (err, doc) {
						if (err) {
							console.log(err);
						}
						callback(new jsonResponse(true, placesToAdd));
					});
				}
				else {
					callback(new jsonResponse(true, placesToAdd));
				}
			}
		});
	};
	this.placesApiTestSearch = function (lat, lng, radius, callback) {
		var types = 'night_club',//'food|bakery|bar|book_store|bowling_alley|cafe|casino|movie_theater|night_club|park|restaurant|university',
			url = "https://maps.googleapis.com/maps/api/place/search/json?key=" + googleServerApiKey + "&location=" + lat + "," + lng + "&radius=5000" + "&types=" + types; //"&radius=" + radius;

		chunkedCall(url, function (response) {
			if (response) {
				var results = response.results,
					formatted = [];
				for (var r in results) {
					//geometry: Object
					////location: Object
					//////lat: 47.7312073
					//////lng: -122.552361
					////viewport: Object
					//////northeast: Object
					////////lat: 47.7443259
					////////lng: -122.5491167
					//////southwest: Object
					//icon: "http://maps.gstatic.com/mapfiles/place_api/icons/geocode-71.png"
					//id: "3d1c3b332fb6c44dd0b007211bf3d4b303f28ed4"
					//name: "Suquamish"
					//place_id: "ChIJwS8NQdQikFQRwGmYU_FJJAc"
					//reference: "CoQBfQAAAETU4auAS-vVd9DgxW_bjqJNAt1f509tvBn87VnVj-WNInfzEcPuJw7yffyEkz-9KVMdolVLjlzjIKx0GRKoM2kp3oLR85U5jNozniNqqYKr_iv3b4vLfZRqVvOJOdCOz54WKceINAnMJ7NSiX3xAllg7Aaomzv57w2OKAnkS8-_EhAxemVLQ3LVqBVgfICzNAm9GhSJaBsLTDyRm6eyOhe_eZc3HnIMHg"
					//scope: "GOOGLE"
					//types: Array[2]
					////0: "locality"
					////1: "political"
					//length: 2
					//__proto__: Array[0]
					//vicinity: "Suquamish"
					formatted.push({
						place_id: results[r].place_id,
						name: results[r].name,
						loc: [parseFloat(results[r].geometry.location.lng, 15), parseFloat(results[r].geometry.location.lat, 15)],
						vicinity: results[r].vicinity
					});
				}
				db.collection('places').insert(formatted, function (err, doc) {
					if (!err) {
						callback(new jsonResponse(true, doc));
					}
					else {
						console.log("ERR: " + err);
						callback(new jsonResponse(false, err));
					}
				});
			}
			else {
				callback(new jsonResponse(false, response));
			}
		});
	};
	this.placesApiSearchByName = function (lat, lng, name, callback) {
		var url = "https://maps.googleapis.com/maps/api/place/search/json?key=" + googleServerApiKey + "&location=" + lat + "," + lng + "&rankby=distance" + "&name=" + name;
		chunkedCall(url, function (response) {
			if (response) {
				var results = response.results,
					formatted = [];

				for (var r in results) {
					formatted.push({
						place_id: results[r].place_id,
						name: results[r].name,
						loc: [results[r].geometry.location.lng, results[r].geometry.location.lat],
						vicinity: results[r].vicinity
					});
				}
				callback(new jsonResponse(true, formatted));
			}
			else {
				callback(new jsonResponse(false, response));
			}
		});
	};
	this.placesSearchName = function (name, callback) {
		var query = {},
			projection = { name: 1, _id: 0 };

		db.collection('places').find(query, projection).toArray(function (err, doc) {
			if (!err) {
				var names = [];
				for (var d in doc) {
					names.push(doc[d].name);
				}
				callback(new jsonResponse(true, names));
			}
			else {
				console.log("ERR: " + err);
				callback(new jsonResponse(false, err));
			}
		});
	};
	this.getPlacesByPlaceId = function (placeIds, callback) {
		var query = { place_id: { $in: placeIds } };

		db.collection('places').find(query).toArray(function (err, doc) {
			syncHandler(err, doc, callback);
		});
	};
	// geocoding
	this.importPlaces = function (address, keyword, callback) {
		var url = "https://maps.googleapis.com/maps/api/geocode/json?key=" + googleServerApiKey + "&address=" + address;
		chunkedCall(url, function (geocode) {
			var loc = geocode.results[0].geometry.location;
			bl.placesApiSearchByName(loc.lat, loc.lng, keyword, function (apiResponse) {
				if (apiResponse.success) {
					bl.createPlacesFromAPI(apiResponse.body, function (newPlacesResponse) {
						callback(new jsonResponse(true, newPlacesResponse));
					});
				}
				else {
					callback(new jsonResponse(false, 'placesApiSearchByName failed'));
				}
			});
		});
	};

	// admin
	this.getEventAdmin = function (eventId, callback) {
		var query = { _id: new ObjectID(eventId) };
		
		s.event.findOne(query)
			.populate('_tags')
			.exec(function (err, events) {
				syncHandler(err, events, callback);
			});
	};
	this.getEventsAdmin = function (callback) {
		s.event.find({})
			.populate('_tags')
			.exec(function (err, events) {
				var model = {};
				model.events = events;
				callback(model);
			});
	};
	this.getPlacesAdmin = function (callback) {
		s.place.find({}, function (err, places) {
			syncHandler(err, places, callback);
		});
	};
	this.getPlaceEventsAdmin = function (placeId, callback) {
		var now = new Date(),
			query = {
				_place: new ObjectID(placeId)
			},
			projection = null,
			options = {
				limit: 15,
				sort: { start: 1 }
			};

		s.event.find(query, projection, options)
			.populate('_tags')
			.exec(function (err, doc) {
				syncHandler(err, doc, callback);
			});
	};
	this.getTagsAdmin = function (callback) {
		s.tag.find({}, function (err, tags) {
			syncHandler(err, tags, callback);
		});
	};
	this.getUsersAdmin = function (callback) {
		s.user.find({}, function (err, users) {
			var model = {};
			model.users = users;
			callback(model);
		});
	};
	this.createEventAdmin = function (eventData, callback) {
		var query = { _id: new ObjectID(eventData._place) };

		// get place
		s.place.findOne(query, function (err, doc) {
			syncHandler(err, doc, function (response) {
				if (response.body) {
					eventData._place = response.body;
					// set the event's location using the place's
					eventData.loc = eventData._place.loc;
				}
				
				// convert string Ids to ObjectIDs
				eventData._tags = eventData._tags.split(",").filter(function (e) { return e });
				for (var t in eventData._tags) {
					eventData._tags[t] = new ObjectID(eventData._tags[t]);
				}

				var eventModel = new s.event(eventData);
				eventModel.save(function (err, doc) {
					syncHandler(err, doc, callback);
				});
			});
		});
	};
	this.updateEventAdmin = function(eventData, callback){
		var response = new jsonResponse(true, null),
            eventQuery = { _id: new ObjectID(eventData._id) };

		s.event.findOne(eventQuery, function (err, doc) {
			syncHandler(err, doc, function (response) {
				var dbEvent = response.body;

				// set the easy ones
				dbEvent.name = eventData.name;
				dbEvent.desc = eventData.desc;
				dbEvent.start = eventData.start;
				dbEvent.end = eventData.end;
				dbEvent.privacy = eventData.privacy;
				dbEvent.intensity_variable = eventData.intensity_variable;

				// set ._tags
				eventData._tags = eventData._tags.split(",").filter(function (e) { return e });
				for (var t in eventData._tags) {
					eventData._tags[t] = new ObjectID(eventData._tags[t]);
				}
				dbEvent._tags = eventData._tags;

				// set privacy
				dbEvent.privacy = eventData.privacy;
				if (dbEvent.privacy === "private") {
					dbEvent._invited = user._friends;
					dbEvent._invited.push(user._id);
				}

				// set place
				dbEvent._place = new ObjectID(eventData._place);

				// update event in db
				dbEvent.save(function (err, doc) {
					syncHandler(err, doc, callback);
				});

			}, true);
		});
	};
	this.deleteEventAdmin = function (eventId, callback) {
		var query = { _id: new ObjectID(eventId) };
		s.event.remove(query, function(err, doc) {
			syncHandler(err, doc, callback);
		});
	};
	this.importEventsCsv = function (data, user, callback) {
		console.log("importing " + data.length + " events...");
		// TODO - load in all the different places and tags and then do bulk insert
		var numUploaded = 0;

		for (var d in data) {
			var eventData = {
				name: data[d][0],
				desc: data[d][1],
				_tags: data[d][2],
				_place: data[d][3],
				start: data[d][4],
				end: data[d][5],
				privacy: data[d][6],
				intensity_variable: data[d][7],
				_created_by: data[d][8]
			};

			bl.createEvent(eventData, user, function (response) {
				if (response.success) console.log(response.body.name + " imported");
				else console.log("failed");

				numUploaded++;
				if (data.length == numUploaded) {
					callback();
				}
			});
		}
	};

	// TEST METHODS
	this.createDefaultTags = function (callback) {
		var filters = [
			{
				glyph: "music",
				label: "Music"
			},
			{
				glyph: "beer",
				label: "Alcohol"
			},
			{
				glyph: "cutlery",
				label: "Food"
			},
			{
				glyph: "dog",
				label: "Pets"
			},
			{
				glyph: "playing_dices",
				label: "Games"
			},
			{
				glyph: "book",
				label: "Books"
			},
			{
				glyph: "gamepad",
				label: "Gaming"
			},
			{
				glyph: "soccer_ball",
				label: "Sports"
			},
			{
				glyph: "tags",
				label: "Sale"
			},
			{
				glyph: "birthday_cake",
				label: "Birthday"
			},
			{
				glyph: "film",
				label: "Movie/TV"
			}
		]
		s.tag.find({}, function (err, existing) {
			if (existing.length === 0) {
				var done = [];
				for (var f in filters) {
					var newTag = new s.tag(filters[f]);
					newTag.save(function (err, doc) {
						done.push(doc);
						if (done.length === filters.length) {
							callback(done);
						}
					});
				}
			}
			else {
				callback(existing);
			}
		});
	}
};

module.exports = BusinessLogic;