var BusinessLogic = function (opts) {
	var bl = this,
		db = opts.database,
		ObjectID = opts.objectID,
		https = opts.https,
		_ = opts.underscore,
		FB = opts.facebook,
		s = opts.schema,
		logJson = function (json) {
			console.log(JSON.stringify(json, null, 2));
		},
		chunkedCall = function (url, onEnd) {
			req = https.get(url, function (res) {
				var pageData = "";
				res.setEncoding('utf8');
				res.on('data', function (chunk) {
					pageData += chunk;
				});

				res.on('end', function () {
					var jsonObj = JSON.parse(pageData);
					onEnd(jsonObj);
				});
			}).on('error', function (e) {
				console.log("Got error: " + e.message);
				onEnd(false);
			});
		},
		jsonResponse = function (success, body, status) {
			return {
				success: success,
				body: body,
				statusCode: success ? 200 : status
			};
		},
		syncHandler = function (err, doc, callback, nullError) {
			if (!err) {
				if (nullError === true && (doc === null || doc === 0)) {
					callback(new jsonResponse(false, "Document not found"));
				}
				else {
					callback(new jsonResponse(true, doc));
				}
			}
			else {
				console.log("ERR: " + err);
				callback(new jsonResponse(false, err));
			}
		};

	// event
	this.getUserEvent = function (fbId, eventId, callback) {
		var query = { _id: new ObjectID(eventId), users: fbId };

		s.event.findOne(query)
			.populate('place')
			.populate('tags')
			.exec(function (err, doc) {
				syncHandler(err, doc, callback, true);
			});
	};
	this.getAllEvents = function (fbId, callback) {
		var now = new Date(),
			maxHigh = new Date(now.getTime() + (3600000 * 48)),
			query = { start: { $lt: maxHigh }, end: { $gt: now }, $or: [{ privacy: 'public' }, { privacy: 'private', invited: fbId }] };

		s.event.find(query, function (err, doc) {
			syncHandler(err, doc, callback, true);
		});
	};
	this.getEventsForSpan = function (span, filters, bounds, fbId, callback) {
		if (filters) {
			for (var f in filters) {
				filters[f] = new ObjectID(filters[f]);
			}
		}
		else {
			filters = [];
		}

		var now = new Date(),
			hours = span == 0 ? 12 : (span == 1 ? 24 : 48),
			high = new Date(now.getTime() + (3600000 * hours)),
			query = {
				$and: [
					{ start: { $lt: high } },
					{ end: { $gt: now } },
					{ tags: { $in: filters } },
					{ $or: [{ privacy: 'public' }, { privacy: 'private', invited: fbId }] },
					{
						loc: {
							$geoIntersects: {
								$geometry: {
									type: "Polygon",
									coordinates: [
										[
										[parseFloat(bounds[0][0], 15), parseFloat(bounds[0][1], 15)],
										[parseFloat(bounds[1][0], 15), parseFloat(bounds[1][1], 15)],
										[parseFloat(bounds[2][0], 15), parseFloat(bounds[2][1], 15)],
										[parseFloat(bounds[3][0], 15), parseFloat(bounds[3][1], 15)],
										[parseFloat(bounds[4][0], 15), parseFloat(bounds[4][1], 15)],
										]
									]
								}
							}
						}
					}
				]
			},
			projection = '_id start end intensity_variable loc users',
			opts = null;

		s.event.find(query, projection, opts, function (err, doc) {
			syncHandler(err, doc, callback);
		});
	};
	this.getEvents = function (ids, callback) {
		console.log(ids);
		var now = new Date(),
		projection = null,
		query = { _id: { $in: ids } },
		opts = {
			sort: { start: 1 }
		};

		s.event.find(query, projection, opts)
			.populate('place')
			.exec(function (err, doc) {
				syncHandler(err, doc, callback);
			});
	};
	this.getUserEvents = function (facebookId, callback) {
		var now = new Date(),
		tomorrow = new Date(now.getTime() + 86400000),
		query = { users: facebookId, end: { $gt: now } },
		projection = null,
		opts = {
			sort: { start: 1 }
		};

		s.event.find(query, projection, opts)
			.populate('place')
			.exec(function (err, doc) {
				syncHandler(err, doc, callback);
			});
	};
	this.getUserOwnedEvents = function (userId, callback) {
		var now = new Date(),
			query = { created_by: new ObjectID(userId), end: { $gt: now } },
			projection = null,
			opts = {
				sort: { start: 1 }
			};

		s.event.find(query, projection, opts)
			.populate('place')
			.exec(function (err, doc) {
				syncHandler(err, doc, callback);
			});
	};
	this.getUserPastEvents = function (facebookId, callback) {
		var now = new Date(),
			query = { users: facebookId, end: { $lt: now } },
			projection = null,
			opts = {
				sort: { start: -1 }
			};

		s.event.find(query, projection, opts)
			.populate('place')
			.exec(function (err, doc) {
				syncHandler(err, doc, callback);
			});
	};
	//// event CRUD
	this.getEvent = function (eventId, callback) {
		var query = { _id: new ObjectID(eventId) };

		s.event.findOne(query)
			.populate('place')
			.populate('tags')
			.exec(function (err, doc) {
				syncHandler(err, doc, callback, true);
			});
	};
	this.createEvent = function (eventData, user, callback) {
		var response = new jsonResponse(true, null),
			query = { _id: new ObjectID(eventData.place) };

		// get place
		s.place.findOne(query, function (err, doc) {
			syncHandler(err, doc, function (response) {
				if (response.success) {
					eventData.place = response.body;

					if (eventData.privacy === "private") {
						eventData.invited = _.map(user.friends, function (f) { return f.facebook_id; });
						eventData.invited.push(user.facebook_id);
					}

					if (user) {
						// set current user to creator
						eventData.created_by = new ObjectID(user._id);

						// add current user to the event
						eventData.users = [];
						eventData.users.push(user.facebook_id);
					}

					// convert string Ids to ObjectIDs
					eventData.tags = eventData.tags.split(",");
					for (var t in eventData.tags) {
						eventData.tags[t] = new ObjectID(eventData.tags[t]);
					}

					// set the event's location using the place's
					eventData.loc = eventData.place.loc;

					//bl.validateEvent(eventData, function (response) {
					var eventModel = new s.event(eventData);
					eventModel.save(function (err, doc) {
						syncHandler(err, doc, callback);
					});
				}
				else {
					callback(response);
				}
			}, true);
		});
	};
	this.updateEvent = function (eventData, user, callback) {
		var response = new jsonResponse(true, null),
			placeQuery = { _id: new ObjectID(eventData.place) };

		// get place
		s.place.where(placeQuery).findOne(function (err, doc) {
			syncHandler(err, doc, function (response) {
				if (response.success) {
					eventData.place = response.body;

					if (eventData.privacy === "private") {
						eventData.invited = _.map(user.friends, function (f) { return f.facebook_id; });
						eventData.invited.push(user.facebook_id);
					}

					// validate model
					//bl.validateEvent(eventData, function (val) {
					var id = eventData._id,
						query = { _id: new ObjectID(eventData._id), created_by: new ObjectID(user._id) };
					// remove _id before update so it doesn't try to set _id
					delete eventData._id;

					var update = { $set: eventData };

					s.event.findOneAndUpdate(query, update, function (err, doc) {
						syncHandler(err, doc, function () {
							response.body = id;
							callback(response);
						});
					});
				}
				else {
					callback(response);
				}
			}, true);
		});
	};
	this.deleteEvent = function (eventId, userId, callback) {
		var query = { _id: new ObjectID(eventId), created_by: new ObjectID(userId) };
		db.collection('events').remove(query, function (err, doc) {
			syncHandler(err, doc, callback, true);
		});
	};
	this.validateEvent_notused = function (event, callback) {
		var val = new jsonResponse(true, {});

		// TODO: check google place, set address, lat/lng, verify that current user can create this event
		// immediately or if it needs to get approved by another account

		event.start = new Date(event.start);
		event.end = new Date(event.end);
		event.tags = event.tags.split(',');

		if (event.start === "Invalid Date") {
			val.success = false;
			val.body.start = "Start datetime is invalid";
		}

		if (event.end === "Invalid Date") {
			val.success = false;
			val.body.end = "End datetime is invalid";
		}

		if (event.end <= event.start) {
			val.success = false;
			val.body.end = "This end date comes after the start date";
		}

		if (event.tags.length === 0) {
			val.success = false;
			val.body.end = "Please select at least one tag for your event";
		}

		if (event.tags.length > 3) {
			val.success = false;
			val.body.end = "You may only select up to 3 event tags";
		}
		if (val.success) {
			bl.getTagsByName(event.tags, function (response) {
				if (response.success) {
					event.tags = response.body;
				}
				else {
					val.success = false;
					val.body.end = "Invalid tags";
				}
				callback(new jsonResponse(val.success, val.body));
			});
		}
		else {
			callback(jsonResponse(val.success, val.body));
		}
	};
	//// event - user relation
	this.addUserToEvent = function (userId, eventId, callback) {
		// TODO: check if event is public or shared w/user
		var query = { _id: new ObjectID(eventId), users: { $nin: [userId] } },
			update = { $addToSet: { users: userId } };

		s.event.findOneAndUpdate(query, update, function (err, doc) {
			syncHandler(err, doc, callback, true);
		});
	};
	this.removeUserFromEvent = function (userId, fbId, eventId, callback) {
		var query = {
			_id: new ObjectID(eventId),
			users: fbId,
			created_by: { $ne: new ObjectID(userId) }
		},
		update = {
			$pull: { users: fbId }
		};

		s.event.findOneAndUpdate(query, update, function (err, doc) {
			syncHandler(err, doc, callback, true);
		});
	};
	//// event tags
	this.getAllTags = function (callback) {
		s.tag.find({}, function (err, doc) {
			syncHandler(err, doc, callback);
		});
	};
	this.getTagsByName = function (tagNames, callback) {
		var query = { name: { $in: tagNames } };

		s.tag.find(query, function (err, doc) {
			syncHandler(err, doc, callback, true);
		});
	};
	this.createReview_notused = function (user, eventId, rating, message, callback) {
		var now = new Date(),
			review = {
				user: {
					_id: new ObjectID(user._id),
					first_name: user.first_name
				},
				rating: rating,
				message: message,
				date_created: now
			},
			query = {
				_id: new ObjectID(eventId),
				users: user.facebook_id,
				end: { $lt: now },
				reviews: { $ne: { user: user } }
			},
			update = { $addToSet: { reviews: review } };

		db.collection('events').update(query, update, function (err, doc) {
			syncHandler(err, doc, callback);
		});
	};
	//// event messaging
	this.addMsgToEvent = function (msg, eventId, fbId, callback) {
		var message = {
			text: msg,
			date: new Date(),
			facebook_id: fbId
		},
			query = { _id: new ObjectID(eventId), users: fbId },
			update = { $push: { messages: message } };

		s.event.findOneAndUpdate(query, update, function (err, doc) {
			syncHandler(err, doc, callback, true);
		});
	};
	// user
	this.getUser = function (userId, callback) {
		var query = { _id: new ObjectID(userId) };

		s.user.findOne(query, function (err, user) {
			syncHandler(err, doc, callback);
		})
	};
	this.getUserPlaces = function (userId, callback) {
		var query = { _id: new ObjectID(userId) },
			projection = { places: 1, _id: 0 };

		s.user.findOne(query, projection)
			.populate('places')
			.exec(function (err, doc) {
				syncHandler(err, doc, callback);
			});
	};
	this.addPlaceToUser = function (userId, placeId, callback) {
		var placeQuery = { _id: new ObjectID(placeId) };

		s.place.findOne(placeQuery, function (err, place) {
			syncHandler(err, place, function (response) {
				if (response.success) {
					// add place to user
					var query = { _id: new ObjectID(userId) },
						update = { $addToSet: { places: place } };

					s.user.findOneAndUpdate(query, update, function (err, doc) {
						syncHandler(err, doc, callback, true);
					});
				}
				else {
					callback(response);
				}
			}, true);
		});
	};
	this.authenticate = function (token, fbUserID, callback) {
		// verify client's sent id with facebook session
		bl.checkFacebookToken(token, fbUserID, function (fbUser) {
			if (fbUser.facebook_id) {
				// query database for user
				var userQuery = { facebook_id: fbUser.facebook_id };
				s.user.findOne(userQuery, function (err, dbUser) {
					if (!err) {
						bl.getFacebookFriends(token, function (friends) {
							var fbFriendIds = _.map(friends, function (f) { return f.facebook_id; });

							if (dbUser === null) {
								// create user in our db
								fbUser["last_login"] = new Date();
								var newUser = new s.user(fbUser);
								newUser.save(function (err, doc) {
									syncHandler(err, doc, callback, true);
								});
							}
							else {
								dbUser["last_login"] = new Date();
								// check if friends list is different since last login
								var diff = _.difference(fbFriendIds, dbUser.friends).length !== 0;
								if (diff) {
									// update user's friends list
									dbUser.friends = fbFriendIds;
									dbUser.save(function (err, dbUser) {
										// update user's private events' authorized list
										var query = { created_by: dbUser._id, privacy: "private" },
											eventUpdate = { $set: { invited: dbUser.friends } };

										s.event.update(query, eventUpdate, function (err, doc) {
											// now return updated dbUser
											if (!err) {
												callback(new jsonResponse(true, dbUser));
											}
											else {
												callback(new jsonResponse(false, err));
											}
										});
									});
								}
								else {
									dbUser.save(function (err, dbUser) {
										callback(new jsonResponse(true, dbUser));
									});
								}
							}
						});
					}
					else {
						callback(new jsonResponse(false, err));
					}
				});
			}
			else {
				console.log("Facebook token authentication failed");
				callback();
			}
		});
	};
	//// facebook
	this.checkFacebookToken = function (token, fbUserID, callback) {
		var fbAuthUrl = "https://graph.facebook.com/me?access_token=" + token;
		chunkedCall(fbAuthUrl, function (response) {
			//	"id": "",
			//	"email": "",
			//	"first_name": "",
			//	"gender": "",
			//	"last_name": "",
			//	"link": "",
			//	"locale": "en_US",
			//	"name": "Aaron ",
			//	"timezone": -7,
			//	"updated_time": "2014-06-11T02:32:33+0000",
			//	"verified": true
			if (response.id === fbUserID) {
				var user = {
					facebook_id: response.id,
					first_name: response.first_name,
					last_name: response.last_name
				};
				callback(user);
			}
			else {
				callback(false);
			}
		});
	};
	this.getFacebookFriends = function (token, callback) {
		var options = {
			fields: "id,name,picture"
		};

		FB.getFbData(token, '/me/friends', options, function (fbResponse) {
			fbResponse = JSON.parse(fbResponse);
			var friendData = _.map(fbResponse.data, function (f) {
				return {
					facebook_id: f.id,
					name: f.name,
					picture_url: f.picture.data.url
				};
			});
			callback(friendData);
		});
	};
	// places
	this.getPlaceById = function (id, callback) {
		var query = { _id: new ObjectID(id) };

		s.place.findOne(query, function (err, doc) {
			syncHandler(err, doc, callback, true);
		});
	};
	this.getPlacePastEvents = function (placeId, fbId, callback) {
		var now = new Date(),
			query = {
				end: { $lt: now },
				$or: [{ privacy: 'public' }, { privacy: 'private', invited: fbId }],
				place: new ObjectID(placeId)
			},
			projection = null,
			options = {
				limit: 15,
				sort: { end: -1 }
			};

		s.event.find(query, projection, options)
			.populate('place', 'name')
			.exec(function (err, doc) {
				syncHandler(err, doc, callback);
			});
	};
	this.placesSearchAll = function (key, lat, lng, name, callback) {
		var placesArray = [],
			query = { name: { $regex: name, $options: 'i' } };

		if (name === null || name === undefined) {
			callback(new jsonResponse(false, "Name is null"));
		}

		s.place.find(query, function (err, doc) {
			if (!err) {
				for (var d in doc) {
					placesArray.push(doc[d]);
				}
				// query google to see if we're missing results
				bl.placesApiSearchByName(key, lat, lng, name, function (apiResponse) {
					if (apiResponse.success) {
						var apiPlaceIds = _.filter(apiResponse.body, function (p) { return p.place_id; });

						// query the returned places against our db to see avoid adding duplicates
						bl.getPlacesByPlaceId(apiPlaceIds, function (dbResponse) {
							if (dbResponse.success) {
								// filter out apiPlaces that are already in db
								var placesToAdd = _.filter(apiResponse.body, function (apiP) {
									return !_.some(dbResponse.body, function (dbP) {
										return dbP.place_id === apiP.place_id;
									});
								});
								for (var p in placesToAdd) {
									placesArray.push(placesToAdd[p]);
								}
								// add any non-local places to db
								if (placesToAdd.length > 0) {
									db.collection('places').insert(placesToAdd, function (err, doc) {
										if (err) {
											console.log(err);
										}
										callback(new jsonResponse(true, placesArray));
									});
								}
								else {
									callback(new jsonResponse(true, placesArray));
								}
							}
						});
					}
				});
			}
			else {
				console.log("ERR: " + err);
				callback(new jsonResponse(false, err));
			}
		});
	};
	this.placesApiTestSearch = function (key, lat, lng, radius, callback) {
		var types = 'night_club',//'food|bakery|bar|book_store|bowling_alley|cafe|casino|movie_theater|night_club|park|restaurant|university',
			url = "https://maps.googleapis.com/maps/api/place/search/json?key=" + key + "&location=" + lat + "," + lng + "&radius=5000" + "&types=" + types; //"&radius=" + radius;

		chunkedCall(url, function (response) {
			if (response) {
				var results = response.results,
					formatted = [];
				console.log(JSON.stringify(results));
				for (var r in results) {
					//geometry: Object
					////location: Object
					//////lat: 47.7312073
					//////lng: -122.552361
					////viewport: Object
					//////northeast: Object
					////////lat: 47.7443259
					////////lng: -122.5491167
					//////southwest: Object
					//icon: "http://maps.gstatic.com/mapfiles/place_api/icons/geocode-71.png"
					//id: "3d1c3b332fb6c44dd0b007211bf3d4b303f28ed4"
					//name: "Suquamish"
					//place_id: "ChIJwS8NQdQikFQRwGmYU_FJJAc"
					//reference: "CoQBfQAAAETU4auAS-vVd9DgxW_bjqJNAt1f509tvBn87VnVj-WNInfzEcPuJw7yffyEkz-9KVMdolVLjlzjIKx0GRKoM2kp3oLR85U5jNozniNqqYKr_iv3b4vLfZRqVvOJOdCOz54WKceINAnMJ7NSiX3xAllg7Aaomzv57w2OKAnkS8-_EhAxemVLQ3LVqBVgfICzNAm9GhSJaBsLTDyRm6eyOhe_eZc3HnIMHg"
					//scope: "GOOGLE"
					//types: Array[2]
					////0: "locality"
					////1: "political"
					//length: 2
					//__proto__: Array[0]
					//vicinity: "Suquamish"
					formatted.push({
						place_id: results[r].place_id,
						name: results[r].name,
						loc: { type: "Point", coordinates: [parseFloat(results[r].geometry.location.lng, 15), parseFloat(results[r].geometry.location.lat, 15)] },
						vicinity: results[r].vicinity
					});
				}
				db.collection('places').insert(formatted, function (err, doc) {
					if (!err) {
						callback(new jsonResponse(true, doc));
					}
					else {
						console.log("ERR: " + err);
						callback(new jsonResponse(false, err));
					}
				});
			}
			else {
				callback(new jsonResponse(false, response));
			}
		});
	};
	this.placesApiSearchByName = function (key, lat, lng, name, callback) {
		var url = "https://maps.googleapis.com/maps/api/place/search/json?key=" + key + "&location=" + lat + "," + lng + "&rankby=distance" + "&name=" + name;
		chunkedCall(url, function (response) {
			if (response) {
				var results = response.results,
					formatted = [];

				for (var r in results) {
					formatted.push({
						place_id: results[r].place_id,
						name: results[r].name,
						loc: { type: "Point", coordinates: [results[r].geometry.location.lng, results[r].geometry.location.lat] },
						vicinity: results[r].vicinity
					});
				}
				callback(new jsonResponse(true, formatted));
			}
			else {
				callback(new jsonResponse(false, response));
			}
		});
	};
	this.placesSearchName = function (name, callback) {
		var query = {},
			projection = { name: 1, _id: 0 };

		db.collection('places').find(query, projection).toArray(function (err, doc) {
			if (!err) {
				var names = [];
				for (var d in doc) {
					names.push(doc[d].name);
				}
				callback(new jsonResponse(true, names));
			}
			else {
				console.log("ERR: " + err);
				callback(new jsonResponse(false, err));
			}
		});
	};
	this.getPlacesByPlaceId = function (placeIds, callback) {
		var query = { place_id: { $in: placeIds } };

		db.collection('places').find(query).toArray(function (err, doc) {
			syncHandler(err, doc, callback);
		});
	};

	// admin
	this.getEventsAdmin = function (callback) {
		s.event.find({})
			.populate('tags')
			.exec(function (err, events) {
				var model = {};
				model.events = events;
				callback(model);
			});
	};
	this.getPlacesAdmin = function (callback) {
		s.place.find({}, function (err, places) {
			var model = {};
			model.places = places;
			callback(model);
		});
	};
	this.getTagsAdmin = function (callback) {
		s.tag.find({}, function (err, tags) {
			var model = {};
			model.tags = tags;
			callback(model);
		});
	};
	this.getUsersAdmin = function (callback) {
		s.user.find({}, function (err, users) {
			var model = {};
			model.users = users;
			callback(model);
		});
	};
	this.importEventsCsv = function (data, user, callback) {
		// TODO - load in all the different places and tags and then do bulk insert
		for (var d in data) {
			var eventData = {
				name: data[d][0],
				desc: data[d][1],
				tags: data[d][2],
				place: data[d][3],
				start: data[d][4],
				end: data[d][5],
				privacy: data[d][6],
				intensity_variable: data[d][7],
				created_by: data[d][8]
			};
			logJson(eventData);
			bl.createEvent(eventData, user);
		}
	};

	// TEST METHODS
	this.insertFilters = function (callback) {
		var filters = [
			{
				glyph: "music",
				label: "Music"
			},
			{
				glyph: "beer",
				label: "Alcohol"
			},
			{
				glyph: "cutlery",
				label: "Food"
			},
			{
				glyph: "dog",
				label: "Pets"
			},
			{
				glyph: "playing_dices",
				label: "Games"
			},
			{
				glyph: "book",
				label: "Books"
			},
			{
				glyph: "gamepad",
				label: "Video Games"
			},
			{
				glyph: "soccer_ball",
				label: "Sports"
			},
			{
				glyph: "birthday_cake",
				label: "Birthday"
			},
			{
				glyph: "film",
				label: "Movie/TV"
			}
		]
		db.collection('tags').insert(filters, function (err, doc) {
			return callback(doc);
		});
	}
};

module.exports = BusinessLogic;