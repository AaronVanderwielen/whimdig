var BusinessLogic = function (Mongo, Https, underscore, facebook) {
	var bl = this,
		db = Mongo.db,
		ObjectID = Mongo.objectID,
		https = Https,
		_ = underscore,
		FB = facebook,
		chunkedCall = function (url, onEnd) {
			req = https.get(url, function (res) {
				var pageData = "";
				res.setEncoding('utf8');
				res.on('data', function (chunk) {
					pageData += chunk;
				});

				res.on('end', function () {
					var jsonObj = JSON.parse(pageData);
					onEnd(jsonObj);
				});
			}).on('error', function (e) {
				console.log("Got error: " + e.message);
				onEnd(false);
			});
		},
		jsonResponse = function (success, body, status) {
			return {
				success: success,
				body: body,
				statusCode: success ? 200 : status
			};
		},
		syncHandler = function (err, doc, callback, nullError) {
			if (!err) {
				if (nullError === true && doc === null) {
					console.log("ERR: Document not found");
					callback(new jsonResponse(false, "Document not found"));
				}
				else {
					callback(new jsonResponse(true, doc));
				}
			}
			else {
				console.log("ERR: " + err);
				callback(new jsonResponse(false, err));
			}
		};

	// event
	this.getAllEvents = function (fbId, callback) {
		var now = new Date(),
			maxHigh = new Date(now.getTime() + (3600000 * 48)),
			query = { start: { $lt: maxHigh }, end: { $gt: now } };//, $or: [{ privacy: 'public' }, { privacy: 'private', users: fbId }] };

		db.collection('events').find(query).sort({ size: -1 }).toArray(function (err, doc) {
			syncHandler(err, doc, function (response) {
				for (var e in response.body) {
					// filter out private events that user is not invited to
					if (doc[e].privacy !== "public") {
						bl.getUser(doc[e].created_by, function (response) {
							var owner = response.body;
							if (doc[e].privacy === "private") {
							}
						}, true);
					}
				}
				callback(doc);
			}, true);
		});
	};
	this.getAllEventsForSpan = function (span, fbId, callback) {
		var now = new Date(),
			hours = span == 0 ? 12 : (span == 1 ? 24 : 48),
			high = new Date(now.getTime() + (3600000 * hours)),
			query = { start: { $lt: high }, end: { $gt: now } };//, $or: [{ privacy: 'public' }, { privacy: 'private', users: fbId }] };

		db.collection('events').find(query).sort({ size: -1 }).toArray(function (err, doc) {
			if (!err) {
				callback(doc);
			}
			else {
				console.log("ERR: " + err);
				return;
			}
		});
	};
	this.getUserEvents = function (userId, callback) {
		var now = new Date(),
		tomorrow = new Date(now.getTime() + 86400000),
		query = { users: userId, end: { $gt: now } };

		db.collection('events').find(query).sort({ start: 1 }).toArray(function (err, doc) {
			if (!err) {
				callback(doc);
			}
			else {
				console.log("ERR: " + err);
				return;
			}
		});
	};
	this.createEvent = function (eventData, callback) {
		var response = new jsonResponse(true, null),
			val;

		// get place
		db.collection('places').findOne({ _id: new ObjectID(eventData.place) }, function (err, doc) {
			syncHandler(err, doc, function (response) {
				if (response.success) {
					eventData.place = doc;
					// validate model
					val = bl.validateEvent(eventData);
					if (val.success) {
						db.collection('events').insert(eventData, function (err, doc) {
							syncHandler(err, doc, callback);
						});
					}
					else {
						callback(val);
					}
				}
				else {
					callback(response);
				}
			}, true);
		});
	};
	this.validateEvent = function (event) {
		console.log(event);
		var val = new jsonResponse(true, {});

		// TODO: check google place, set address, lat/lng, verify that current user can create this event
		// immediately or if it needs to get approved by another account

		event.start = new Date(event.start);
		event.end = new Date(event.end);

		if (event.start === "Invalid Date") {
			val.success = false;
			val.body["start"] = "Start datetime is invalid";
		}

		if (event.end === "Invalid Date") {
			val.success = false;
			val.body["end"] = "End datetime is invalid";
		}

		if (event.end <= event.start) {
			val.success = false;
			val.body["end"] = "This end date comes after the start date";
		}

		return new jsonResponse(val.success, val.body);
	}
	this.addUserToEvent = function (userId, eventId, callback) {
		// TODO: check if event is public or shared w/user
		var query = { _id: new ObjectID(eventId), users: { $nin: [userId] } },
			update = { $inc: { size: 10 }, $addToSet: { users: userId } };

		db.collection('events').update(query, update, function (err, doc) {
			if (!err) {
				callback(doc);
			}
			else {
				console.log("ERR: " + err);
				return;
			}
		});
	};
	this.removeUserFromEvent = function (userId, eventId, callback) {
		var query = { _id: new ObjectID(eventId), users: userId },
		update = { $inc: { size: -10 }, $pull: { users: userId } };

		db.collection('events').update(query, update, function (err, doc) {
			if (!err) {
				callback(doc);
			}
			else {
				console.log("ERR: " + err);
				return;
			}
		});
	};
	// user
	this.getUser = function (userId, callback) {
		var query = { _id: new ObjectID(userId) };

		db.collection('users').findOne(query, function (err, doc) {
			syncHandler(err, doc, callback);
		});
	};
	this.getFacebookFriends = function (token, callback) {
		var options = {
			fields: "id,name,picture"
		};

		FB.getFbData(token, '/me/friends', options, function (fbResponse) {
			fbResponse = JSON.parse(fbResponse);
			var friendData = _.map(fbResponse.data, function (f) {
				return {
					facebook_id: f.id,
					name: f.name,
					picture_url: f.picture.data.url
				};
			});
			callback(friendData)
		});
	};
	this.getUserPlaces = function (userId, callback) {
		var query = { _id: new ObjectID(userId) },
			projection = { places: 1, _id: 0 };

		db.collection('users').findOne(query, projection, function (err, doc) {
			syncHandler(err, doc, callback);
		});
	};
	this.addPlaceToUser = function (userId, placeId, callback) {
		db.collection('places').findOne({ _id: new ObjectID(placeId) }, function (err, place) {
			if (!err) {
				if (place !== null) {
					// add place to user
					var query = { _id: new ObjectID(userId) },
						update = { $push: { places: place } };

					db.collection('users').update(query, update, function (err, doc) {
						syncHandler(err, doc, callback, true);
					});
				}
				else {
					callback(new jsonResponse(false, "Place does not exist"));
				}
			}
			else {
				callback(new jsonResponse(false, err));
			}
		});
	}
	this.getUserIds = function () {
		var contacts = getUserContacts();
		// now look in mongo database for that user
	};
	this.checkFacebookToken = function (token, fbUserID, callback) {
		var fbAuthUrl = "https://graph.facebook.com/me?access_token=" + token;
		chunkedCall(fbAuthUrl, function (response) {
			//	"id": "",
			//	"email": "",
			//	"first_name": "",
			//	"gender": "",
			//	"last_name": "",
			//	"link": "",
			//	"locale": "en_US",
			//	"name": "Aaron ",
			//	"timezone": -7,
			//	"updated_time": "2014-06-11T02:32:33+0000",
			//	"verified": true
			if (response.id === fbUserID) {
				var user = {
					facebook_id: response.id,
					first_name: response.first_name,
					last_name: response.last_name
				};
				callback(user);
			}
			else {
				callback(false);
			}
		});
	};
	this.authenticate = function (token, fbUserID, callback) {
		// verify client's sent id with facebook session
		bl.checkFacebookToken(token, fbUserID, function (fbUser) {
			if (fbUser.facebook_id) {
				// query database for user
				var query = { facebook_id: fbUser.facebook_id };
				db.collection('users').findOne(query, function (err, dbUser) {
					if (!err) {
						bl.getFacebookFriends(token, function (friends) {
							fbUser.friends = friends;

							if (dbUser === null) {
								// create user in our db
								console.log("create user in our db");
								db.collection('users').insert(fbUser, function (err, doc) {
									if (!err) {
										// now return inserted dbUser
										db.collection('users').findOne({ facebook_id: fbUser.facebook_id }, function (err, doc) {
											syncHandler(err, doc, callback, true);
										});
									}
									else {
										callback(new jsonResponse(false, err));
									}
								});
							}
							else {
								//update db user with fbUser
								db.collection('users').update({ _id: dbUser._id }, { $set: fbUser }, function (err, doc) {
									if (!err) {
										// now return updated dbUser
										db.collection('users').findOne({ facebook_id: fbUser.facebook_id }, function (err, doc) {
											syncHandler(err, doc, callback, true);
										});
									}
									else {
										callback(new jsonResponse(false, err));
									}
								});
							}
						});
					}
					else {
						callback(new jsonResponse(false, err));
					}
				});
			}
			else {
				console.log("Facebook token authentication failed");
				callback();
			}
		});
	};
	// places
	this.placesSearchAll = function (key, lat, lng, name, callback) {
		var placesArray = new Array(),
			query = { name: { $regex: name, $options: 'i' } };

		if (name === null || name === undefined) {
			callback(new jsonResponse(false, "Name is null"));
		}

		db.collection('places').find(query).toArray(function (err, doc) {
			if (!err) {
				for (var d in doc) {
					placesArray.push(doc[d]);
				}
				bl.placesApiSearchByName(key, lat, lng, name, function (response) {
					if (response.success) {
						var placesToAdd = new Array();
						for (var p in response.body) {
							// if place doesn't exist in our db
							if (!_.some(placesArray, function (pl) { return pl.place_id === response.body[p].place_id; })) {
								// add to array and to our database
								placesArray.push(response.body[p]);
								placesToAdd.push(response.body[p]);
							}
						}
						// add any non-local places to db
						if (placesToAdd.length > 0) {
							db.collection('places').insert(placesToAdd, function (err, doc) {
								if (err) {
									console.log(err);
								}
								callback(new jsonResponse(true, placesArray));
							})
						}
						else {
							callback(new jsonResponse(true, placesArray));
						}
					}
				});
			}
			else {
				console.log("ERR: " + err);
				callback(new jsonResponse(false, err));
			}
		});
	};
	this.placesApiTestSearch = function (key, lat, lng, radius, callback) {
		var types = 'night_club',//'food|bakery|bar|book_store|bowling_alley|cafe|casino|movie_theater|night_club|park|restaurant|university',
			url = "https://maps.googleapis.com/maps/api/place/search/json?key=" + key + "&location=" + lat + "," + lng + "&radius=5000" + "&types=" + types; //"&radius=" + radius;

		chunkedCall(url, function (response) {
			if (response) {
				var results = response.results,
					formatted = new Array();
				console.log(JSON.stringify(results));
				for (var r in results) {
					//geometry: Object
					////location: Object
					//////lat: 47.7312073
					//////lng: -122.552361
					////viewport: Object
					//////northeast: Object
					////////lat: 47.7443259
					////////lng: -122.5491167
					//////southwest: Object
					//icon: "http://maps.gstatic.com/mapfiles/place_api/icons/geocode-71.png"
					//id: "3d1c3b332fb6c44dd0b007211bf3d4b303f28ed4"
					//name: "Suquamish"
					//place_id: "ChIJwS8NQdQikFQRwGmYU_FJJAc"
					//reference: "CoQBfQAAAETU4auAS-vVd9DgxW_bjqJNAt1f509tvBn87VnVj-WNInfzEcPuJw7yffyEkz-9KVMdolVLjlzjIKx0GRKoM2kp3oLR85U5jNozniNqqYKr_iv3b4vLfZRqVvOJOdCOz54WKceINAnMJ7NSiX3xAllg7Aaomzv57w2OKAnkS8-_EhAxemVLQ3LVqBVgfICzNAm9GhSJaBsLTDyRm6eyOhe_eZc3HnIMHg"
					//scope: "GOOGLE"
					//types: Array[2]
					////0: "locality"
					////1: "political"
					//length: 2
					//__proto__: Array[0]
					//vicinity: "Suquamish"
					formatted.push({
						place_id: results[r].place_id,
						name: results[r].name,
						loc: { type: "point", coordinates: [results[r].geometry.location.lng, results[r].geometry.location.lat] },
						vicinity: results[r].vicinity
					});
				}

				db.collection('places').insert(formatted, function (err, doc) {
					if (!err) {
						callback(new jsonResponse(true, doc));
					}
					else {
						console.log("ERR: " + err);
						callback(new jsonResponse(false, err));
					}
				});
			}
			else {
				callback(new jsonResponse(false, response));
			}
		});
	};
	this.placesApiSearchByName = function (key, lat, lng, name, callback) {
		var url = "https://maps.googleapis.com/maps/api/place/search/json?key=" + key + "&location=" + lat + "," + lng + "&rankby=distance" + "&name=" + name;
		chunkedCall(url, function (response) {
			if (response) {
				var results = response.results,
					formatted = new Array();

				for (var r in results) {
					formatted.push({
						place_id: results[r].place_id,
						name: results[r].name,
						loc: { type: "point", coordinates: [results[r].geometry.location.lng, results[r].geometry.location.lat] },
						vicinity: results[r].vicinity
					});
				}
				callback(new jsonResponse(true, formatted));
			}
			else {
				callback(new jsonResponse(false, response));
			}
		});
	};
	this.placesSearchName = function (name, callback) {
		var query = {},
			projection = { name: 1, _id: 0 };

		db.collection('places').find(query, projection).toArray(function (err, doc) {
			if (!err) {
				var names = new Array();
				for (var d in doc) {
					names.push(doc[d].name);
				}
				callback(new jsonResponse(true, names));
			}
			else {
				console.log("ERR: " + err);
				callback(new jsonResponse(false, err));
			}
		});
	};

	// TEST METHODS
	this.bellinghamEvents = function (callback) {
		var now = new Date().getTime(),
			oneHour = 3600000; // in milliseconds

		var slightlyLater = new Date(now + oneHour * 1),
			bitLater = new Date(now + oneHour * 2),
			later = new Date(now + oneHour * 4),
			muchLater = new Date(now + oneHour * 8),
			wayLater = new Date(now + oneHour * 12);

		now = new Date(now);
		console.log(now.toString());

		var testEvents = [
			{
				place: "New York Pizza",
				name: "Seahawks game",
				desc: "We will be showing the Seahawks game tonight, half off beer! Come watch the Seahawks destroy the Broncos! Go Hawks!",
				loc: { type: "Point", coordinates: [-122.483066, 48.744216] },
				address: "902 N State St #105",
				city: "Bellingham",
				state: "WA",
				zip: "98225",
				start: now,
				end: slightlyLater,
				created_by: "",
				users: [0, 1, 2]
			},
			{
				place: "The Wild Buffalo",
				name: "Party at the Buff!",
				desc: "Funky, brick-walled club with bar & dance floor offers live blues, rock, reggae shows & more.",
				loc: { type: "Point", coordinates: [-122.480433, 48.750867] },
				address: "208 W Holly St",
				city: "Bellingham",
				state: "WA",
				zip: "98225",
				start: slightlyLater,
				end: bitLater,
				created_by: "",
				users: [0, 1]
			},
			{
				place: "Glow",
				name: "Ladies Night",
				desc: "Positioned above Bob's burger and brew, we're going to have a party and have a bunch of sexy ladies there.",
				loc: { type: "Point", coordinates: [-122.478111, 48.748749] },
				address: "202 E Holly St",
				city: "Bellingham",
				state: "WA",
				zip: "98225",
				start: bitLater,
				end: later,
				created_by: "",
				users: [0, 1, 2, 3, 4, 5]
			},
			{
				place: "The Underground",
				name: "80's Night",
				desc: "great dance floor, great sound system and frankly the bartenders are awesome and moving quick... See you there!",
				loc: { type: "Point", coordinates: [-122.479095, 48.747937] },
				address: "211 E Chestnut St",
				city: "Bellingham",
				state: "WA",
				zip: "98225",
				start: later,
				end: muchLater,
				created_by: "",
				users: [0, 1, 2, 3, 4, 5, 6, 7]
			},
			{
				place: "Rumors Cabaret",
				name: "Bi-Centennial Party Night",
				desc: "Hopping, gay-friendly nightspot offering live music, DJs, drag shows & cocktails",
				loc: { type: "Point", coordinates: [-122.480506, 48.747829] },
				address: "1119 Railroad Ave",
				city: "Bellingham",
				state: "WA",
				zip: "98225",
				start: later,
				end: wayLater,
				created_by: "",
				users: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
			}
		];
		db.collection('events').insert(testEvents, function (err, doc) {
			return callback(doc);
		});
	};
}

module.exports = BusinessLogic;